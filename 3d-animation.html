<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NAMMI Constructions - 3D Logo Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #FFFFFF;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        .control-panel {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 50px;
            box-shadow: 0 8px 32px rgba(30, 58, 95, 0.15);
            z-index: 1000;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .replay-btn {
            padding: 12px 24px;
            border: 2px solid #1E3A5F;
            background: #1E3A5F;
            color: #FFFFFF;
            font-weight: 600;
            font-size: 14px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .replay-btn:hover {
            background: #2A4A6F;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 58, 95, 0.3);
        }

        .progress-bar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 6px;
            background: rgba(30, 58, 95, 0.1);
            border-radius: 3px;
            overflow: hidden;
            z-index: 1000;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #1E3A5F, #8B9DAF);
            transition: width 0.1s linear;
            border-radius: 3px;
        }

        .info-text {
            color: #8B9DAF;
            font-size: 13px;
            font-weight: 400;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 999;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #E5E5E5;
            border-top-color: #1E3A5F;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <p style="color: #1E3A5F; font-weight: 600;">Loading 3D Scene...</p>
    </div>

    <div class="control-panel">
        <button class="replay-btn" onclick="replayAnimation()">
            <span>↻ Replay Animation</span>
        </button>
        <span class="info-text">5s • 3D Element-by-Element Construction</span>
    </div>

    <div id="canvas-container"></div>

    <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    
    <script>
        let scene, camera, renderer, animationProgress = 0;
        let elements = {};
        let animationStartTime = null;
        const ANIMATION_DURATION = 5000; // 5 seconds

        // Initialize Three.js scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xFFFFFF);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 12);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight1.position.set(10, 10, 5);
            dirLight1.castShadow = true;
            dirLight1.shadow.mapSize.width = 2048;
            dirLight1.shadow.mapSize.height = 2048;
            scene.add(dirLight1);

            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            dirLight2.position.set(-10, 5, -5);
            scene.add(dirLight2);

            const pointLight = new THREE.PointLight(0xffffff, 0.4);
            pointLight.position.set(0, 5, 0);
            scene.add(pointLight);

            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(30, 30);
            const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.1 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create all logo elements
            createCrane();
            createConcreteBlock();
            createSwooshCurve();
            createHouse();
            createBlocksStack();
            createBrickWall();
            createGear();
            createText();

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            // Start animation
            animationStartTime = Date.now();
            animate();
        }

        // Crane with lattice tower
        function createCrane() {
            const craneGroup = new THREE.Group();
            craneGroup.position.set(-3.5, 2.5, 0);
            craneGroup.scale.set(0, 0, 0);

            const craneMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1E3A5F, 
                metalness: 0.6, 
                roughness: 0.3 
            });

            // Cabin
            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.3, 0.3),
                craneMaterial
            );
            cabin.position.set(0, 0.2, 0);
            cabin.castShadow = true;
            craneGroup.add(cabin);

            // Horizontal arm
            const arm = new THREE.Mesh(
                new THREE.BoxGeometry(3.2, 0.08, 0.08),
                craneMaterial
            );
            arm.position.set(1.8, 0.1, 0);
            arm.castShadow = true;
            craneGroup.add(arm);

            // Counter weight arm
            const counterArm = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.08, 0.08),
                craneMaterial
            );
            counterArm.position.set(-0.8, 0.1, 0);
            counterArm.castShadow = true;
            craneGroup.add(counterArm);

            // Tower
            const tower = new THREE.Mesh(
                new THREE.BoxGeometry(0.12, 2.5, 0.12),
                craneMaterial
            );
            tower.position.set(0, -1.2, 0);
            tower.castShadow = true;
            craneGroup.add(tower);

            // Lattice beams
            for (let i = 0; i < 5; i++) {
                const beam = new THREE.Mesh(
                    new THREE.BoxGeometry(0.25, 0.04, 0.04),
                    craneMaterial
                );
                beam.position.set(0, -0.3 - i * 0.5, 0);
                beam.rotation.z = Math.PI / 4;
                beam.castShadow = true;
                craneGroup.add(beam);
            }

            // Hook cable
            const cable = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 1.8, 8),
                new THREE.MeshStandardMaterial({ color: 0x5A6B7D, metalness: 0.7, roughness: 0.2 })
            );
            cable.position.set(2.8, -0.6, 0);
            craneGroup.add(cable);

            // Hook
            const hook = new THREE.Mesh(
                new THREE.ConeGeometry(0.06, 0.15, 6),
                new THREE.MeshStandardMaterial({ color: 0x8B9DAF, metalness: 0.8, roughness: 0.2 })
            );
            hook.position.set(2.8, -1.6, 0);
            hook.castShadow = true;
            craneGroup.add(hook);

            scene.add(craneGroup);
            elements.crane = craneGroup;
        }

        // Concrete block
        function createConcreteBlock() {
            const blockGroup = new THREE.Group();
            blockGroup.position.set(0.5, 3, 0);
            blockGroup.visible = false;

            const block = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.35, 0.35),
                new THREE.MeshStandardMaterial({ 
                    color: 0x9CA8B3, 
                    metalness: 0.2, 
                    roughness: 0.8 
                })
            );
            block.castShadow = true;
            blockGroup.add(block);

            scene.add(blockGroup);
            elements.block = blockGroup;
        }

        // Swoosh curve
        function createSwooshCurve() {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-3.2, -1.4, 0),
                new THREE.Vector3(-2, -1.6, 0.1),
                new THREE.Vector3(-1, -1.7, 0.2),
                new THREE.Vector3(0, -1.75, 0.3),
                new THREE.Vector3(1, -1.7, 0.2),
                new THREE.Vector3(2, -1.5, 0.1),
                new THREE.Vector3(3, -1.2, 0),
                new THREE.Vector3(3.5, -0.9, -0.1),
            ]);

            const tubeGeometry = new THREE.TubeGeometry(curve, 64, 0.09, 12, false);
            const tubeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1E3A5F, 
                metalness: 0.6, 
                roughness: 0.3,
                transparent: true,
                opacity: 0
            });

            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube.castShadow = true;
            scene.add(tube);
            elements.swoosh = tube;
        }

        // House
        function createHouse() {
            const houseGroup = new THREE.Group();
            houseGroup.position.set(-0.8, -0.3, 0);
            houseGroup.scale.set(0, 0, 0);

            // Roof
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(1.1, 0.9, 4),
                new THREE.MeshStandardMaterial({ color: 0x1E3A5F, metalness: 0.3, roughness: 0.6 })
            );
            roof.position.set(0, 1.3, 0);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            houseGroup.add(roof);

            // Walls
            const walls = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 1.3, 1.3),
                new THREE.MeshStandardMaterial({ color: 0xF5F5F5, metalness: 0.05, roughness: 0.9 })
            );
            walls.position.set(0, 0.5, 0);
            walls.castShadow = true;
            houseGroup.add(walls);

            // Windows
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1E3A5F, 
                opacity: 0.9, 
                transparent: true 
            });

            const leftWindow = new THREE.Mesh(
                new THREE.BoxGeometry(0.35, 0.35, 0.04),
                windowMaterial
            );
            leftWindow.position.set(-0.45, 0.65, 0.66);
            leftWindow.castShadow = true;
            houseGroup.add(leftWindow);

            const rightWindow = new THREE.Mesh(
                new THREE.BoxGeometry(0.35, 0.35, 0.04),
                windowMaterial
            );
            rightWindow.position.set(0.45, 0.65, 0.66);
            rightWindow.castShadow = true;
            houseGroup.add(rightWindow);

            // Door
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(0.45, 0.85, 0.04),
                new THREE.MeshStandardMaterial({ color: 0x1E3A5F })
            );
            door.position.set(0, -0.05, 0.66);
            door.castShadow = true;
            houseGroup.add(door);

            scene.add(houseGroup);
            elements.house = houseGroup;
        }

        // Building blocks stack
        function createBlocksStack() {
            const stackGroup = new THREE.Group();
            stackGroup.position.set(1.2, 0.2, 0);
            stackGroup.scale.set(0, 0, 0);

            for (let i = 0; i < 5; i++) {
                const cylinder = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: i % 2 === 0 ? 0xB8C1CA : 0xC8D0D8, 
                        metalness: 0.15, 
                        roughness: 0.85 
                    })
                );
                cylinder.position.set(0, i * 0.28, 0);
                cylinder.castShadow = true;
                stackGroup.add(cylinder);

                // Groove line
                const groove = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.36, 0.36, 0.02, 16),
                    new THREE.MeshStandardMaterial({ color: 0x8B9DAF })
                );
                groove.position.set(0, i * 0.28 + 0.13, 0);
                stackGroup.add(groove);
            }

            scene.add(stackGroup);
            elements.blocks = stackGroup;
        }

        // Brick wall
        function createBrickWall() {
            const wallGroup = new THREE.Group();
            wallGroup.position.set(2.8, 0, 0);
            wallGroup.scale.set(0, 0, 0);

            const wall = new THREE.Mesh(
                new THREE.BoxGeometry(0.7, 1.6, 0.4),
                new THREE.MeshStandardMaterial({ color: 0xE8EBED, metalness: 0.05, roughness: 0.95 })
            );
            wall.castShadow = true;
            wallGroup.add(wall);

            // Brick lines
            const lineMaterial = new THREE.MeshStandardMaterial({ color: 0x8B9DAF });

            for (let i = 0; i < 7; i++) {
                const hLine = new THREE.Mesh(
                    new THREE.BoxGeometry(0.72, 0.015, 0.015),
                    lineMaterial
                );
                hLine.position.set(0, -0.7 + i * 0.24, 0.21);
                wallGroup.add(hLine);
            }

            scene.add(wallGroup);
            elements.wall = wallGroup;
        }

        // Gear
        function createGear() {
            const gearGroup = new THREE.Group();
            gearGroup.position.set(0.8, -1.2, 0.3);
            gearGroup.scale.set(0, 0, 0);

            const gearMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1E3A5F, 
                metalness: 0.7, 
                roughness: 0.3 
            });

            // Main body
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.42, 0.42, 0.18, 12),
                gearMaterial
            );
            body.castShadow = true;
            gearGroup.add(body);

            // Center hole
            const hole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.22, 12),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF, metalness: 0.5, roughness: 0.4 })
            );
            gearGroup.add(hole);

            // Teeth
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const x = Math.cos(angle) * 0.46;
                const z = Math.sin(angle) * 0.46;
                
                const tooth = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.18, 0.16),
                    gearMaterial
                );
                tooth.position.set(x, 0, z);
                tooth.rotation.y = angle;
                tooth.castShadow = true;
                gearGroup.add(tooth);
            }

            scene.add(gearGroup);
            elements.gear = gearGroup;
        }

        // Text
        function createText() {
            const textGroup = new THREE.Group();
            textGroup.position.set(0, -2.5, 0);
            textGroup.scale.set(0, 0, 0);

            const textMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1E3A5F, 
                metalness: 0.5, 
                roughness: 0.4 
            });

            // Create simple 3D text using shapes
            const loader = new THREE.FontLoader();
            // We'll use simple geometry for text since we don't have font files

            scene.add(textGroup);
            elements.text = textGroup;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (animationStartTime) {
                const elapsed = Date.now() - animationStartTime;
                animationProgress = Math.min(elapsed / ANIMATION_DURATION, 1);

                updateElements(animationProgress);
                updateProgressBar(animationProgress);

                // Camera rotation
                const rotation = animationProgress * Math.PI * 0.2;
                camera.position.x = Math.sin(rotation) * 1.5;
            }

            renderer.render(scene, camera);
        }

        // Update elements based on progress
        function updateElements(progress) {
            // Crane (0-0.12)
            if (progress >= 0 && progress < 0.12) {
                const scale = progress / 0.12;
                elements.crane.scale.setScalar(scale);
            } else if (progress >= 0.12) {
                elements.crane.scale.setScalar(1);
            }

            // Block (0.12-0.24)
            if (progress >= 0.12) {
                elements.block.visible = true;
                if (progress < 0.24) {
                    const blockProgress = (progress - 0.12) / 0.12;
                    elements.block.position.y = 3 - blockProgress * 2.2;
                } else {
                    elements.block.position.y = 0.8;
                }
            }

            // Swoosh (0.24-0.32)
            if (progress >= 0.24) {
                const swooshProgress = Math.min((progress - 0.24) / 0.08, 1);
                elements.swoosh.material.opacity = swooshProgress;
            }

            // House (0.3-0.46)
            if (progress >= 0.3 && progress < 0.46) {
                const houseScale = (progress - 0.3) / 0.16;
                elements.house.scale.setScalar(houseScale);
            } else if (progress >= 0.46) {
                elements.house.scale.setScalar(1);
            }

            // Blocks (0.46-0.54)
            if (progress >= 0.46 && progress < 0.54) {
                const blocksScale = (progress - 0.46) / 0.08;
                elements.blocks.scale.setScalar(blocksScale);
            } else if (progress >= 0.54) {
                elements.blocks.scale.setScalar(1);
            }

            // Wall (0.54-0.62)
            if (progress >= 0.54 && progress < 0.62) {
                const wallScale = (progress - 0.54) / 0.08;
                elements.wall.scale.setScalar(wallScale);
            } else if (progress >= 0.62) {
                elements.wall.scale.setScalar(1);
            }

            // Gear (0.62-0.72) - with rotation
            if (progress >= 0.62 && progress < 0.72) {
                const gearProgress = (progress - 0.62) / 0.1;
                elements.gear.scale.setScalar(gearProgress);
                elements.gear.rotation.y = gearProgress * Math.PI * 2;
            } else if (progress >= 0.72) {
                elements.gear.scale.setScalar(1);
                elements.gear.rotation.y = Math.PI * 2;
            }

            // Text (0.72+)
            if (progress >= 0.72) {
                const textScale = Math.min((progress - 0.72) / 0.1, 1);
                elements.text.scale.setScalar(textScale);
            }
        }

        // Update progress bar
        function updateProgressBar(progress) {
            document.getElementById('progress-fill').style.width = (progress * 100) + '%';
        }

        // Replay animation
        function replayAnimation() {
            animationProgress = 0;
            animationStartTime = Date.now();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start everything
        window.addEventListener('load', init);
    </script>
</body>
</html>
